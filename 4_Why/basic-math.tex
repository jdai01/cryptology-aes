\subsection{Mathematics Foundation}

As all bytes in the \gls{AES} algorithm are interpreted as finite field elements, they can be added and multiploed. 
However, these operations are different from decimal numbers and are outlined below.


\subsubsection{The Finite Field \texorpdfstring{$\mathrm{\Gls{GF}}(2^8)$}{\Gls{GF}(2^8)}}
\label{sec:galois}

The field $\mathrm{\Gls{GF}}(2^8)$ consists of 256 elements and is formed by polynomials with binary coefficients, each of degree less than 8. All arithmetic in this field is done modulo the irreducible polynomial:

\begin{align}
    m(x) = x^8 + x^4 + x^3 + x + 1 \label{eq:irred-poly}
\end{align}

Each element corresponds to an 8-bit byte. Operations in the field include:
\begin{itemize}
    \item \textbf{Addition:} Performed as bitwise XOR
    \item \textbf{Multiplication:} Polynomial multiplication modulo $m(x)$
    \item \textbf{Inversion:} Found using the Extended Euclidean Algorithm
\end{itemize}

These operations are critical in the \Gls{AES} algorithm, particularly in transformations like \texttt{SubBytes} and \texttt{MixColumns}, which depend on the structure of $\mathrm{\Gls{GF}}(2^8)$ to ensure both security and performance.

\subsubsection{Addition}
\label{sec:addition}

The addition of two elements in a finite field is perfomed with the \texttt{XOR} operation, denoted by $\oplus$, with
\begin{align}
    c_i &= a_i \oplus b_i \quad \forall i \in [0, 7]
\end{align}
in $GF(2^8)$.


\subsubsection{Multiplication}
\label{sec:multiplication}

Multiplication in $\mathrm{\Gls{GF}}(2^8)$ involves polynomial arithmetic, denoted by $\bullet$. 
Each byte is treated as a polynomial of degree at most 7 with binary coefficients. 
Multiplication is then done modulo an irreducible polynomial of degree 8, which for \Gls{AES} is described in Eq. \ref{eq:irred-poly}.

For instance, the byte $\{57\}$ (binary 01010111) represents the polynomial:

\[
x^6 + x^4 + x^2 + x + 1
\]

To multiply two bytes $a(x)$ and $b(x)$, we compute:

\begin{align}
    c(x) = a(x) \bullet b(x) \mod m(x) \label{eq:mul}
\end{align}

An example would be:

\[
\{57\} \bullet \{83\} = \{c1\}
\]

Because this operation can be computationally heavy, efficient implementations often use lookup tables or optimized routines like \texttt{xtime}, which simplifies multiplication by $x$.

\subsubsection{Multiplication by \texorpdfstring{$x$}{x}}
\label{sec:multx}

Multiplying a byte by $x$ (equivalent to $\{02\}$) involves a left shift of the byte, with an additional XOR with $\{1b\}$ if the leftmost bit (most significant bit) is 1:

\begin{align}
    \text{xtime}(b) =
    \begin{cases}
    b \ll 1, & \text{if } b_7 = 0 \\
    (b \ll 1) \oplus \{1b\}, & \text{if } b_7 = 1
    \end{cases}
\end{align}

This allows for fast multiplication by $x$ modulo the \Gls{AES} irreducible polynomial.
